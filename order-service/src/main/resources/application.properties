spring.application.name=order-service
server.port=6005
spring.config.import=optional:configserver:${SPRING_CLOUD_CONFIG_URI:http://localhost:8888/}

# ============================================
# KAFKA CONFIGURATION
# ============================================
spring.kafka.producer.bootstrap-servers=${SPRING_KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
# Địa chỉ Kafka broker mà producer sẽ kết nối

## Producer configuration
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
# Serializer dùng để chuyển đổi Key của message thành mảng byte
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
# Serializer dùng để chuyển đổi Value của message thành JSON

## Kafka Consumer configuration
spring.kafka.consumer.bootstrap-servers=${SPRING_KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
# Địa chỉ Kafka broker mà consumer kết nối
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer

# Cho phép deserializer tin tưởng tất cả các package
spring.kafka.consumer.properties.spring.json.trusted.packages=*

# --- FIX LỖI DESERIALIZE KHÁC PACKAGE ---
# Ép kiểu dữ liệu về DTO local thay vì dùng thông tin type header từ Producer
# (Rất quan trọng khi Payment Service gửi event nhưng Order Service lại dùng DTO khác package)
spring.kafka.consumer.properties.spring.json.value.default.type=com.example.orderservice.dto.PaymentEvent
spring.kafka.consumer.properties.spring.json.use.type.headers=false

## Topic names (Biến tùy chỉnh dùng trong code)
kafka.topic.order=order-topic
kafka.topic.notification=notification-topic
kafka.topic.payment=payment-topic
kafka.topic.updatestatusorder=update-order-topic
# Phase 3: Async Stock Decrease
kafka.topic.stock-decrease=stock-decrease-topic
kafka.topic.order-compensation=order-compensation-topic

## Consumer group
spring.kafka.consumer.group-id=order-service-group

# ============================================
# SWAGGER & CONFIG SERVER
# ============================================
springdoc.swagger-ui.path=/swagger-ui.html

# ============================================
# GHN API Configuration (Giao Hàng Nhanh)
# ============================================
ghn.api.url=https://dev-online-gateway.ghn.vn/shiip/public-api
ghn.api.token=57404b9d-d3e9-11f0-a3d6-dac90fb956b5
ghn.shop.id=198371

# ============================================
# Database Connection Pool (HikariCP)
# ============================================
# Maximum số connections trong pool - Order Service cần nhiều connections vì xử lý nhiều orders
# Giá trị 60 phù hợp với service có traffic cao, xử lý nhiều database operations
spring.datasource.hikari.maximum-pool-size=60

# Minimum số idle connections luôn giữ sẵn trong pool
# Giữ 10 connections sẵn để tránh delay khi có request mới
spring.datasource.hikari.minimum-idle=10

# Timeout khi chờ connection từ pool (milliseconds)
# Nếu không có connection available trong 30 giây -> throw exception
spring.datasource.hikari.connection-timeout=30000

# Timeout cho idle connections (milliseconds = 10 phút)
# Tự động đóng connections không được sử dụng sau 10 phút để giải phóng tài nguyên
spring.datasource.hikari.idle-timeout=600000

# Maximum lifetime của connection (milliseconds = 30 phút)
# Đóng connection sau 30 phút dù đang được sử dụng để tránh stale connections
spring.datasource.hikari.max-lifetime=1800000

# Phát hiện connection leak (milliseconds = 1 phút)
# Cảnh báo nếu connection không được đóng sau 1 phút (có thể do code quên close)
spring.datasource.hikari.leak-detection-threshold=60000

# Connection test query - Kiểm tra connection còn sống trước khi sử dụng
# SELECT 1 là query đơn giản nhất, nhanh nhất để test connection
spring.datasource.hikari.connection-test-query=SELECT 1

# Pool name - Tên pool để dễ debug và monitor trong logs
spring.datasource.hikari.pool-name=OrderServiceHikariPool

# ============================================
# Tomcat Thread Pool (High Traffic Service)
# ============================================
# Maximum số threads xử lý HTTP requests đồng thời
# 500 threads cho phép xử lý 500 requests cùng lúc (phù hợp với order service có traffic cao)
server.tomcat.threads.max=500

# Minimum số threads giữ sẵn (luôn có sẵn, không cần tạo mới)
# Giữ 50 threads sẵn để xử lý requests ngay lập tức, tránh delay
server.tomcat.threads.min-spare=50

# Maximum số connections chờ trong queue (khi tất cả threads đang busy)
# Khi 500 threads đều đang xử lý, 1000 connections tiếp theo sẽ chờ trong queue
server.tomcat.accept-count=1000

# Maximum số connections TCP (tổng số connections server có thể nhận)
# 10000 connections cho phép server chịu tải cao, phù hợp với microservice có nhiều clients
server.tomcat.max-connections=10000

# Connection timeout (milliseconds = 20 giây)
# Đóng connection nếu không có request trong 20 giây để giải phóng tài nguyên
server.tomcat.connection-timeout=20000

# Enable compression - Nén response để giảm bandwidth
# Giảm kích thước response (JSON, HTML, CSS, JS) -> tăng tốc độ load
server.compression.enabled=true

# Các MIME types sẽ được nén
# Nén text/html, JSON, CSS, JS để giảm kích thước response
server.compression.mime-types=text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json

# Minimum response size để nén (bytes)
# Chỉ nén response >= 1KB (1024 bytes), vì nén response nhỏ không hiệu quả
server.compression.min-response-size=1024

# ============================================
# Spring Boot Actuator (Monitoring)
# ============================================
# Expose các endpoints của Actuator để monitor service
# health: Kiểm tra service còn sống không
# metrics: Xem các metrics (CPU, memory, requests, etc.)
# info: Thông tin về service
# prometheus: Export metrics theo format Prometheus (để tích hợp với Grafana)
management.endpoints.web.exposure.include=health,metrics,info,prometheus

# Hiển thị chi tiết health check (database, disk, etc.)
management.endpoint.health.show-details=always

# Tag application name cho metrics
# Giúp phân biệt metrics của các services khác nhau trong Prometheus/Grafana
management.metrics.tags.application=${spring.application.name}

# ============================================
# Hibernate Batch Processing (Performance Optimization)
# ============================================
# Batch size: Number of statements to batch before executing
# 50 is optimal for most cases - balances between memory and performance
spring.jpa.properties.hibernate.jdbc.batch_size=50

# Order inserts: Group INSERT statements together
# Reduces DB round-trips from N inserts to ~1-2 batch operations
spring.jpa.properties.hibernate.order_inserts=true

# Order updates: Group UPDATE statements together
# Same benefit as order_inserts but for UPDATEs
spring.jpa.properties.hibernate.order_updates=true

# Batch versioned data: Allow batching for entities with @Version
# Important for entities with optimistic locking
spring.jpa.properties.hibernate.batch_versioned_data=true

# Optional: Enable for debugging batch operations
spring.jpa.properties.hibernate.show_sql=false
spring.jpa.properties.hibernate.format_sql=false
logging.level.org.hibernate.SQL=INFO
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# ============================================
# Async Executor Configuration (Cart Cleanup)
# ============================================
# Core pool size: Number of threads to keep alive
# 10 threads for async cart cleanup operations
spring.task.execution.pool.core-size=10

# Max pool size: Maximum number of threads
# Can scale up to 20 threads during high load
spring.task.execution.pool.max-size=20

# Queue capacity: Number of tasks to queue when all threads are busy
# 100 tasks can wait in queue before rejection
spring.task.execution.pool.queue-capacity=100

# Thread name prefix for easier debugging
spring.task.execution.thread-name-prefix=async-cart-
